// Code generated by sqlc. DO NOT EDIT.
// source: queries.sql

package db

import (
	"context"
	"time"
)

const addCurrency = `-- name: AddCurrency :one
INSERT INTO currencies(code)
VALUES($1)
ON CONFLICT(code) DO NOTHING
RETURNING code
`

func (q *Queries) AddCurrency(ctx context.Context, code string) (string, error) {
	row := q.db.QueryRow(ctx, addCurrency, code)
	var outCode string
	err := row.Scan(&outCode)
	return code, err
}

const getAllExchangeRatesForCurrency = `-- name: GetAllExchangeRatesForCurrency :many
SELECT from_currency, to_currency, rate, rate_at from exchange_rates
WHERE from_currency=$1
`

func (q *Queries) GetAllExchangeRatesForCurrency(ctx context.Context, fromCurrency string) ([]ExchangeRate, error) {
	rows, err := q.db.Query(ctx, getAllExchangeRatesForCurrency, fromCurrency)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExchangeRate
	for rows.Next() {
		var i ExchangeRate
		if err := rows.Scan(
			&i.FromCurrency,
			&i.ToCurrency,
			&i.Rate,
			&i.RateAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCurrencies = `-- name: GetCurrencies :many
SELECT code from currencies
ORDER BY code
`

func (q *Queries) GetCurrencies(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getCurrencies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var code string
		if err := rows.Scan(&code); err != nil {
			return nil, err
		}
		items = append(items, code)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExchangeRatesForCurrency = `-- name: GetExchangeRatesForCurrency :many
SELECT from_currency, to_currency, rate, rate_at from exchange_rates
WHERE from_currency=$1 AND to_currency=ANY($2)
`

type GetExchangeRatesForCurrencyParams struct {
	FromCurrency string
	ToCurrency   []string
}

func (q *Queries) GetExchangeRatesForCurrency(ctx context.Context, arg GetExchangeRatesForCurrencyParams) ([]ExchangeRate, error) {
	rows, err := q.db.Query(ctx, getExchangeRatesForCurrency, arg.FromCurrency, arg.ToCurrency)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExchangeRate
	for rows.Next() {
		var i ExchangeRate
		if err := rows.Scan(
			&i.FromCurrency,
			&i.ToCurrency,
			&i.Rate,
			&i.RateAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectSecret = `-- name: GetProjectSecret :one
SELECT hashed_secret
FROM api_keys
WHERE project_id=$1
`

func (q *Queries) GetProjectSecret(ctx context.Context, projectID string) ([]byte, error) {
	row := q.db.QueryRow(ctx, getProjectSecret, projectID)
	var hashed_secret []byte
	err := row.Scan(&hashed_secret)
	return hashed_secret, err
}

const setExchangeRate = `-- name: SetExchangeRate :one
INSERT INTO exchange_rates(from_currency, to_currency, rate, rate_at)
VALUES($1,$2,$3,$4)
ON CONFLICT (from_currency, to_currency)
DO
    UPDATE SET rate=EXCLUDED.rate, rate_at=EXCLUDED.rate_at
RETURNING from_currency, to_currency, rate, rate_at
`

type SetExchangeRateParams struct {
	FromCurrency string
	ToCurrency   string
	Rate         float32
	RateAt       time.Time
}

func (q *Queries) SetExchangeRate(ctx context.Context, arg SetExchangeRateParams) (ExchangeRate, error) {
	row := q.db.QueryRow(ctx, setExchangeRate,
		arg.FromCurrency,
		arg.ToCurrency,
		arg.Rate,
		arg.RateAt,
	)
	var i ExchangeRate
	err := row.Scan(
		&i.FromCurrency,
		&i.ToCurrency,
		&i.Rate,
		&i.RateAt,
	)
	return i, err
}

const setProjectSecret = `-- name: SetProjectSecret :one
INSERT INTO api_keys(project_id, hashed_secret)
VALUES($1,$2)
ON CONFLICT(project_id)
DO
    UPDATE SET hashed_secret=EXCLUDED.hashed_secret
returning project_id, hashed_secret
`

type SetProjectSecretParams struct {
	ProjectID    string
	HashedSecret []byte
}

func (q *Queries) SetProjectSecret(ctx context.Context, arg SetProjectSecretParams) (ApiKey, error) {
	row := q.db.QueryRow(ctx, setProjectSecret, arg.ProjectID, arg.HashedSecret)
	var i ApiKey
	err := row.Scan(&i.ProjectID, &i.HashedSecret)
	return i, err
}
