// Code generated by sqlc. DO NOT EDIT.
// source: queries.sql

package db

import (
	"context"
	"time"
)

const addCurrency = `-- name: AddCurrency :one
INSERT INTO currencies(code)
VALUES($1)
ON CONFLICT(code) DO NOTHING
RETURNING code
`

func (q *Queries) AddCurrency(ctx context.Context, code string) (string, error) {
	row := q.db.QueryRowContext(ctx, addCurrency, code)
	var code string
	err := row.Scan(&code)
	return code, err
}

const getCurrencies = `-- name: GetCurrencies :many
SELECT code from currencies
ORDER BY code
`

func (q *Queries) GetCurrencies(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getCurrencies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var code string
		if err := rows.Scan(&code); err != nil {
			return nil, err
		}
		items = append(items, code)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExchangeRates = `-- name: GetExchangeRates :many
SELECT from_currency, to_currency, rate, rateat from exchange_rates
WHERE from_currency = $1 AND to_currency=ANY($2)
`

type GetExchangeRatesParams struct {
	FromCurrency string
	ToCurrency   string
}

func (q *Queries) GetExchangeRates(ctx context.Context, arg GetExchangeRatesParams) ([]ExchangeRate, error) {
	rows, err := q.db.QueryContext(ctx, getExchangeRates, arg.FromCurrency, arg.ToCurrency)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExchangeRate
	for rows.Next() {
		var i ExchangeRate
		if err := rows.Scan(
			&i.FromCurrency,
			&i.ToCurrency,
			&i.Rate,
			&i.Rateat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectSecret = `-- name: GetProjectSecret :one
SELECT hashed_secret
FROM api_keys
WHERE project_id=$1
`

func (q *Queries) GetProjectSecret(ctx context.Context, projectID string) (string, error) {
	row := q.db.QueryRowContext(ctx, getProjectSecret, projectID)
	var hashed_secret string
	err := row.Scan(&hashed_secret)
	return hashed_secret, err
}

const setExchangeRate = `-- name: SetExchangeRate :one
INSERT INTO exchange_rates(from_currency, to_currency, rate, rateAt)
VALUES($1,$2,$3,$4)
ON CONFLICT (from_currency, to_currency)
DO
    UPDATE SET rate=EXCLUDED.rate, rateAt=EXCLUDED.rateAt
RETURNING from_currency, to_currency, rate, rateat
`

type SetExchangeRateParams struct {
	FromCurrency string
	ToCurrency   string
	Rate         string
	Rateat       time.Time
}

func (q *Queries) SetExchangeRate(ctx context.Context, arg SetExchangeRateParams) (ExchangeRate, error) {
	row := q.db.QueryRowContext(ctx, setExchangeRate,
		arg.FromCurrency,
		arg.ToCurrency,
		arg.Rate,
		arg.Rateat,
	)
	var i ExchangeRate
	err := row.Scan(
		&i.FromCurrency,
		&i.ToCurrency,
		&i.Rate,
		&i.Rateat,
	)
	return i, err
}

const setProjectSecret = `-- name: SetProjectSecret :one
INSERT INTO api_keys(project_id, hashed_secret)
VALUES($1,$2)
ON CONFLICT(project_id)
DO
    UPDATE SET hashed_secret=EXCLUDED.hashed_secret
returning project_id, hashed_secret
`

type SetProjectSecretParams struct {
	ProjectID    string
	HashedSecret string
}

func (q *Queries) SetProjectSecret(ctx context.Context, arg SetProjectSecretParams) (ApiKey, error) {
	row := q.db.QueryRowContext(ctx, setProjectSecret, arg.ProjectID, arg.HashedSecret)
	var i ApiKey
	err := row.Scan(&i.ProjectID, &i.HashedSecret)
	return i, err
}
